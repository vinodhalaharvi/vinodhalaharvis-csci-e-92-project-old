!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
LINE_MAX	shell.h	/^const int LINE_MAX = 256;$/;"	v
MAX_COMMAND_LINE_ARGUMENTS	shell.c	11;"	d	file:
MAX_LIST_SIZE	map.h	7;"	d
MAX_STRING_LENGTH	shell.c	10;"	d	file:
_MAP_H	map.h	2;"	d
_clock	shell.h	/^typedef struct _clock {$/;"	s
boolean	map.h	/^typedef enum { false, true } boolean; $/;"	t	typeref:enum:__anon1
calendar	shell.c	/^void calendar(unsigned long days, $/;"	f
clock	shell.h	/^} clock;$/;"	t	typeref:struct:_clock
cmd_date	shell.c	/^int cmd_date(int argc, char *argv[]){ $/;"	f
cmd_echo	shell.c	/^int cmd_echo(int argc, char *argv[]){ $/;"	f
cmd_exit	shell.c	/^int cmd_exit(int argc, char *argv[]){ $/;"	f
cmd_help	shell.c	/^int cmd_help(int argc, char *argv[]){ $/;"	f
cmd_set	shell.c	/^int cmd_set(int argc, char *argv[]){ $/;"	f
commandEntry	shell.c	/^struct commandEntry {$/;"	s	file:
command_func_type	shell.h	/^typedef int (*command_func_type) (int argc, char * argv[]); $/;"	t
commands	shell.c	/^} commands[] = {$/;"	v	typeref:struct:commandEntry
contains	map.c	/^boolean contains(node_type * node, key_type key){$/;"	f
data	shell.h	/^    } data; $/;"	m	struct:_clock	typeref:struct:_clock::__anon2
days	shell.c	/^time_t days(time_t seconds){$/;"	f
delete	map.c	/^void delete(node_type **head, key_type key){$/;"	f
do_command	shell.c	/^int do_command(char line[LINE_MAX + 1], int *argc, char * argv[]){ $/;"	f
double_quote_check	shell.c	/^void double_quote_check(int *ch){ $/;"	f
env	shell.c	/^static node_type * env = NULL; $/;"	v	file:
false	map.h	/^typedef enum { false, true } boolean; $/;"	e	enum:__anon1
freenode	map.c	/^void freenode(node_type * node){ $/;"	f
functionp	shell.c	/^    int (*functionp)(int , char *[]);$/;"	m	struct:commandEntry	file:
get	map.c	/^value_type get(node_type * node, key_type key){$/;"	f
getNumDaysInThisMonth	shell.c	/^int getNumDaysInThisMonth(long year, long month){ $/;"	f
get_command_function	shell.c	/^command_func_type get_command_function(char line[LINE_MAX+1], int *argc, char * argv[]){ $/;"	f
hour	shell.h	/^        unsigned hour; $/;"	m	struct:_clock::__anon2
hours	shell.c	/^time_t hours(time_t seconds){ $/;"	f
init	shell.c	/^void init(clock *clock){ $/;"	f
inside_double_quote	shell.c	/^static int inside_double_quote = 0; $/;"	v	file:
isSlash	shell.c	/^boolean isSlash(char ch){ $/;"	f
is_leap_year	shell.c	/^boolean is_leap_year(int yearno){ $/;"	f
isline	shell.c	/^boolean isline(char line[LINE_MAX +1]){ $/;"	f
join	shell.c	/^char *join(char * stringArray[], char * delimiter){ $/;"	f
key	map.h	/^    key_type key; $/;"	m	struct:node_type
key_type	map.h	/^typedef char * key_type; $/;"	t
lmonthdays	shell.c	/^int lmonthdays[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; $/;"	v
main	shell.c	/^int main() {$/;"	f
match	map.c	/^boolean match(key_type key, key_type otherkey) { $/;"	f
memory_free	shell.c	/^void memory_free(char line[LINE_MAX +1], int *argc, char * argv[]){ $/;"	f
minute	shell.h	/^        unsigned minute; $/;"	m	struct:_clock::__anon2
minutes	shell.c	/^time_t minutes(time_t seconds){ $/;"	f
months	shell.c	/^char * months[12]= { $/;"	v
name	shell.c	/^    char *name;$/;"	m	struct:commandEntry	file:
next	map.h	/^    struct node_type * next; $/;"	m	struct:node_type	typeref:struct:node_type::node_type
nlmonthdays	shell.c	/^int nlmonthdays[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; $/;"	v
node_type	map.h	/^typedef struct node_type {$/;"	s
node_type	map.h	/^} node_type;$/;"	t	typeref:struct:node_type
prev	map.h	/^    struct node_type * prev; $/;"	m	struct:node_type	typeref:struct:node_type::node_type
print	map.c	/^void print(node_type * environ){$/;"	f
printStringArray	shell.c	/^void printStringArray(char *stringArray[], int howmany){ $/;"	f
print_boolean	shell.c	/^void print_boolean(boolean bool){ $/;"	f
print_error	shell.c	/^void print_error(char line[LINE_MAX +1], int *argc, char * argv[]){ $/;"	f
process_line	shell.c	/^int  process_line(char line[LINE_MAX + 1], int *argc, char * argv[]) {$/;"	f
put	map.c	/^node_type * put(node_type * node, key_type key, value_type value){$/;"	f
second	shell.h	/^        unsigned second; $/;"	m	struct:_clock::__anon2
size	map.h	/^    int size; $/;"	m	struct:node_type
split	shell.c	/^void split(char line[LINE_MAX +1], char * delimiter, int *argc, char *argv[]){$/;"	f
splitString	shell.c	/^void splitString(char * string, char delimiter, $/;"	f
subescapse_char	shell.c	/^char subescapse_char(char ch){ $/;"	f
timeofday	shell.c	/^void timeofday(clock * clock, unsigned long seconds){ $/;"	f
toLong	shell.c	/^long toLong(char * string, int base){ $/;"	f
toString	shell.c	/^char * toString(int monthno){ $/;"	f
toUnsignedLong	shell.c	/^long toUnsignedLong(char * string, int base){ $/;"	f
true	map.h	/^typedef enum { false, true } boolean; $/;"	e	enum:__anon1
value	map.h	/^    value_type value; $/;"	m	struct:node_type
value_type	map.h	/^typedef char * value_type; $/;"	t
